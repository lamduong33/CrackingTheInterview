#+TITLE: CPP Reference Sheet

* Basic Features:
** Tests (comparisons):
*** If:
You can initialize and compare inside the if block. This improves readability
and keeps the variable in the scope of the if block. Do this when you can.
#+BEGIN_SRC cpp
if (auto n = vect.size(); n < 10) {}
#+END_SRC
** Constants:
- *const*: promise to not change the value (such as pi).
- constexpr: same as const, but will be evaluated at compile time instead of
runtime. This has better performance. This is preferred over C macros.
*** Using const in parameters
#+BEGIN_SRC cpp
void foo(const std::string& s)
#+END_SRC
This is passing by value in C++. You don't want to be copying a large class into
the parameter. Instead of using pointers, use reference (&), instead. Using
const means that we won't modify that value at all.
** Assignment and Initialization:
- Two ways to assign a value.
#+BEGIN_SRC cpp
int x = 0; // This is the traditional C way.
int y{0}; // This will prevent "narrowing conversion".
#+END_SRC
- Assignment is simply copying the value from the right hand side and assigning
it to the left hand side.
- Initialization is to make unitialized memory into a valid object.
  + An unintialized variable is int x; where as an intialized one is int x = 0;
  + Think of assignment as one way to initialize.
- int& r = x is not an assignment but is an intialization.
** Memory:
*** Pointers:
**** Raw Pointer
**** Smart Pointers
**** nullptr:
- Used to avoid confusion between NULL, which is just 0, and a pointer value.
*** References:
- Essentially pointers but you don't have to dereference them like you do with
pointers.
- Think of it as an alias, anything that happens to the reference variable will
also happen to the original variable. Example:
#+BEGIN_SRC cpp
int x = 5, y = 3;
int &z = x, &r = y;
z = r; // x will now have the value of 3. Whatever you do to z will happen to x.
#+END_SRC
- There is cannot be null references. References are /NOT/ pointers. They do not
represent addresses like pointers do. References have their own addresses that
do not change. References need to be initialized to some value.
- Often used as function paramters, because:
  1. It is faster to work with a reference rather than a copy.
  2. We know that it is the object being used instead of a copy being used
     inside the function
**** Returning references:
- Pretty damn useful for writing more terse code:
#+BEGIN_SRC cpp
double array[] = {1.0, 2.0, 3.0};
double& setSize(int index)
{
    return array[index]; // be careful when returning outside of scope
}
setSize(1) = 20.0;
#+END_SRC
*** Dynamic Memory:
- The /new/ keyword allocates memory from an area called /free store/ (heap)
- The /delete/ keyword will free the allocated memory.
** For Loop:
- C-style for loop:
  #+BEGIN_SRC cpp
  for (auto i = 0 ; i < container.size() ; i++)
  #+END_SRC
- *Range for loop*:
  #+BEGIN_SRC cpp
  for (auto element : container) {}// think of this as the Python-style for loop
  for (auto& element)
  #+END_SRC.
** Function:
*** Argument Passing:
**** Pass-by-value:
- Your typical function that returns a copy of something.
- For passing by small values (something that's cheap to copy, e.g. int)
**** Pass-by-reference:
- A void function that modifies the arguments that are references.
- For passing large values (larger objects with more than 3 pointers as a rule
of thumb).
- Usually include the /const/ keyword to ensure performance if we are not
modifying the parameters.
*** Default Arguments:
- Similar to default arguments in Python:
#+BEGIN_SRC cpp
void print(int value, int base = 10); // This will use the default value of 10
#+END_SRC
*** Returning Reference:
- Return by reference when we want to retrieve something that is not local to the
function, e.g. an accessor member function of an object. Do NOT return a reference
that is local to the function, since it will be destroyed. Compilers will watch
out for this though.
*** Structured Binding:
- The mechanism to give local names to members of a class object
#+BEGIN_SRC cpp
auto [n,v] = read_entry(num); // read_entry() is a member function of a class

// Could also be used for traversing
std::map>string,int> myMap;
for (const auto& [key,value] : myMap)
    std::cout << key "," << value << std::endl;
#+END_SRC
* User-Defined Types:
** Structures:
- Identical to classes, but everything is *public by default*. This is not good
  encapsulation in OOP principles (I think).
- However, the convention is that you use structs to bundle data, like in C.
- Use . to access members through names and references.
- Use -> to access members through pointers.
** Classes:
*** General:
- All of a class functions that are declared must be defined (implemented).
- Overloading: another function with different parameters.
- Overriding: a parent and a child with the same function and same parameters.
**** Concrete Classes:
- Behave "Just like built-in types", for example, a vector is just like an array.
- For types that don't change often.
**** Abstract Classes:
- A type that completely insulates a user from implementation details.
- Must allocate objects on the free store and access them through references or pointers.
- Similar to Java interface:
  + Using the /virtual/ keyword, we can set up interfaces.
  + Functions have the /virtual/ keywords are called virtual functions, which
    define the abstraction for the abstract class.
    - Virtual functions aren't just interfaces. *FOR A FUNCTION TO BE INHERITED,*
    *IT MUST USE THE VIRTUAL KEYWORD*. Functions without virtual keywords in the
    superclass cannot be inherited by the subclass.
  + A virtual function that is set to =0 is called a *pure virtual* function,
    meaning that each class MUST implement this (just like a Java interface)
    #+BEGIN_SRC cpp
    virtual double& operator[](int) = 0; // inherited class must implement
    #+END_SRC
  + Not all virtual functions are required. Pure virtual functions are required
    to be implemented by classes that inherit.
- Abstract classes can be used cleverly without being initialized:
#+BEGIN_SRC cpp

#+END_SRC
**** Classes in Class Hierarchies
*** Constructor:
- Guaranteed to initialize data members. Can be initialized in this fashion:
#+BEGIN_SRC cpp
Object(int param) :memberVariable{new double[param]}, otherMemVar{param} {}
#+END_SRC
- Default constructor: a constructor without any arguments
- /new/ operations should not be performed outside of an abstraction (e.g. a
class) and they are known as "naked *new* operators" when they are outside of a
class. As a result, memory should be allocated inside constructors.
**** Invariants:
- Essentially constraints for classes defined by constructor. This is created by
  error/exception handling within the class.
- *Well-designed codes have very few try-catch blocks.*
- Invariants help us to understand precisely what we want out of a class and
  force us to be specific.
*** Destructor:
- The destructor and constructor form the idea of /Resource Acquisition Is
Initialization/ (RAII) concept. Memory is allocated and deallocated upon the
initialization and termination of an object.
- Use the *delete* keyword to deallocate memory that was allocated in the
constructor:
 + *delete* will delete a single object.
 + *detete[]* will delete an array.
*** User-defined operators:
- Meant to work with primitive operations, such as +, -, /, ==, etc.
#+BEGIN_SRC cpp
bool operator==(complex a, complex b) {return a.real() == b.real();}
#+END_SRC
- Use this with caution and follow convention.
*** Polymorphism:
- Subclass and superclass (think parent and child class)
** Unions:
- Generally, just use /variant/ instead. Look at next section for reference.
- A /struct/ in which all members are allocated at the same address so that the
union occupies only as much space as its largest member. This is to ensure that
if only one value is used in the union, there is no wasted space.
#+BEGIN_SRC cpp
/* Only one value will be used. Either p or i, not both. */
union Value
{
    Node* p; // since Node* is a pointer, it is bigger. So the size of Value
    int i;   // will be the size of a pointer.
}
#+END_SRC
- Generally, you want to put unions inside classes to be less error-prone.
Unions should only be accessed via member functions.
*** Variant:
- /variant/: A standard library type that can be used instead of unions.
- variants are safer and simpler to use than unions.
#+BEGIN_SRC cpp
struct Entry
{
    std::string name;
    std::variant<Node*, int> v;
}
void f(Entry*)
{
    if (std::holds_alternative<int>(pe->v)) // does the variant hold an int?
        std::cout << std::get<int>(pe->v);  // if it does
}
#+END_SRC
** Enumerations:
- Enumerate values and/or represent small sets of integer values. By default,
enums will hold a set of ints.
- They're meant to make code more readable
#+BEGIN_SRC cpp
enum class Color{red, blue, green};
Color color = Color::red;
#+END_SRC
- The reason that class follows enum is because the this enum is strongly typed
and everything inside is scoped. The "enum class" declaration is very type-safe.
- By default has only assignment, initialization, and comparisons defined.
- "Plain" enums:
  + enums without the "class" keyword
  + Implicitly converts to their integer value
  + Generally don't use this but they are still common in C++ code
* Modularity
** Modules:
- Module essentially eliminates the usage of header files. You can still use
them side by side but modules no longer do not use header files .
- The /#include/ keyword is error-prone and contain long build time. If you
/#include/ a header file in 101 translation units, you will compile it 101 times.
The order of include statements also matter and can produce many bugs. A module,
on the other hand, is compiled once so compile time is faster and is more maintainable.
- Using the /module/ keyword, we can define module and tell where to /export/ and
where to /import/ using the respective keywords.
- Using the /import/ keyword, user will not see what the imported module import,
i.e. import is not transitive.
** Header Files:
- Speed up compilation time due to *"separate compilation"*.
- Logically separate parts of program. Think of the program as many separate
modules to be compiled with well-defined depencies.
- A .cpp file compiled by itself, along with its .h files that it includes, is
called  a /translation unit/. A program can consist of many translation units.
** Namespaces:
- Declaration that some declarations belong together and that their names
shouldn't clash with other names (think namespace std)
- If namespace access gets too long, we can use the /using/ keyword to reduce it,
e.g. using std::get and then using get() directly without name
* Data Structures:
** vector<T>:
- A variable-size vector
** list<T>:
- A doubly-linked list
- O(1) insertion at beginning or end
  + O(n) insertion in between
** forward_list<T>:
** deque<T>:
** set<T>
** multiset<T>
** map<K,V>:
- Balanced binary search tree (red-black tree)
- It is *ordered*
- Also known as an /associative array/ or /dictionary/
- Can be subscripted, e.g. myMap[2]
- Lookup is *O(log(n))*
- Insertion and deletion are *O(log(n)) + rebalance*
** multimap<K,V>:
** unordered_map<K,V>:
- A hash table
- *O(1)* average for lookup, insertion, and deletion
- *O(n)* worst case for lookup, insertion, and deletion
- Similar to a stack, the first element inserted will /USUALLY/ be the last one
  + Just like the name, this map is unordered. Usually, the first one inserted 
    is at .end(). However, this /order is NOT GUARUANTEED/. It is NOT ordered.
- Element lookup: 2 ways
  + using count(): used to see if it exists
    #+BEGIN_SRC cpp
    if (mymap.count(x) > 0) {} // true if exists in map
    #+END_SRC
  + using find(): better since it's tailored for search
    #+BEGIN_SRC cpp
    auto search = mymap.find(input);
    if(search == mymap.end()) {} // returns end() if not found
    #+END_SRC
- Deletion:
  + By element:
  + By range:
    #+BEGIN_SRC cpp
    // Remember that .begin() is the element last inserted
    map.erase(map.begin(), map.find(key));
    #+END_SRC
** unordered_multimap<K,V>:
** unordered_set<K,V>:
- Hashed set
- For looking up:
#+BEGIN_SRC cpp
result = set.find(element); // hashed set
if (result == my.end()) {} // true if element is found
#+END_SRC
** unordered_multiset<K,V>:
* Error Handling:
** try, catch, throw:
#+BEGIN_SRC cpp
try
{
    // Code goes here
    throw std::out_of_range{"Vector::operator[]"};
}
catch(std::out_of_range& err) // out_of_range is an STL exception
{
    std::cerr << err.what() << "\n";
}

#+END_SRC
** noexcept:
- Use the /noexcept/ keyword when a function never throws an exception.
- std::terminate() is called when a function with noexcept keyword in its
declaration throws an exception. Anytime an exception occurs inside the
function, the program will terminate.
** assert:
- Assert that a condition must be true at run time.
- If the condition fails, the program will terminate in "debug mode", otherwise
assert will not be checked.
#+BEGIN_SRC cpp
assert(pointer != nullptr);
#+END_SRC
** static_assert:
- For assertion during compile time. Most important when make assertions about
types and used as parameters in generic programming (templates)
#+BEGIN_SRC cpp
contexpr int pi = 3.14; // declared and evaluated during compile time
static_assert(arc < pi, "The arc has to be a circle");
static_assert(sizeof(int) <= 4, "This system does not have int less than 4 bytes");
#+END_SRC
* Techniques:
* STL:
* Tricks:
- Convert char to string (atoi) fast:
    - int integer = charInt - '0'
